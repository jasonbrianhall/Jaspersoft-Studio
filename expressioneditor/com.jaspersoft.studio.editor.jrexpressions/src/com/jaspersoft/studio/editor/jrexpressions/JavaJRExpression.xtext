grammar com.jaspersoft.studio.editor.jrexpressions.JavaJRExpression /*with org.eclipse.xtext.common.Terminals  */  hidden(WS, ML_COMMENT, SL_COMMENT)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate javaJRExpression "http://www.jaspersoft.com/studio/editor/jrexpressions/JavaJRExpression"

Model:
	Expression;

Expression:
	Creator | (Cast)? condExpr=ConditionalExpression 
	;
	
MethodInvocation:
	fullyQualifiedMethodName=MethodName args=Arguments
;

MethodName:
	(prefixQMN+=IDENTIFIER dots+=DOT)* methodName=IDENTIFIER
;

BaseJRExpr:
	fieldToken=FieldToken | parameterToken=ParameterToken | variableToken=VariableToken;
	
Arguments:
	leftP=LPAREN (exprLst=ExpressionList)? rightP=RPAREN;

ExpressionList:
	expressions+=Expression
	(commas+=COMMA expressions+=Expression)*;

BaseCommonExpression returns Expression:
	basejrexpr=BaseJRExpr | literal=Literal | LPAREN Expression RPAREN | MethodInvocation
;

Cast:
	lpar=LPAREN (ptype=PrimitiveType|arrtype=ArrayType|clazztype=ClassOrInterfaceType) rpar=RPAREN;

//primary:
//	parExpression=parExpression
//	| this='this'
//	(dot+=DOT identifier+=IDENTIFIER)*
//	(identifierSuffix=identifierSuffix)?
//	| identifier+=IDENTIFIER
//	(dot+=DOT identifier+=IDENTIFIER)*
//	(identifierSuffix=identifierSuffix)?
//	| 'super'
//	superSuffix=superSuffix
//	| literal=Literal
//	| creator=Creator
//	| primitiveType=PrimitiveType
//	(lbrack+=LBRACKET rbrack+=RBRACKET)*
//	dot+=DOT 'class'
//	| 'void' dot+=DOT 'class';


// ========================== CONDITIONAL EXPRESSION STUFF ========================== //
ConditionalExpression returns Expression:
	TestExpression 
	('?' okReturnedExpr=Expression ':' koReturnedExpr=Expression)? 
;

TestExpression returns Expression:
	OrExpression
;

OrExpression returns Expression:
	andExp+=AndExpression ( '||' andExp+=AndExpression)*
;

AndExpression returns Expression:
	primaryCond+=PrimaryCondExpression ( '&&' primaryCond+=PrimaryCondExpression)*
;

PrimaryCondExpression returns Expression:
	expr=BaseBooleanExpr
;

BaseBooleanExpr returns Expression:
	(NOT)? EqualityExpression
;

// ========================== COMPARE EXPRESSIONS STUFF ========================== //
EqualityExpression returns Expression:
	instanceof+=InstanceOfExpression ((EQUAL | NOTEQUAL) instanceof+=InstanceOfExpression)*
;

RelationalExpression returns Expression:
	rel+=AdditiveExpression (RelationalOp rel+=AdditiveExpression)*
;

InstanceOfExpression returns Expression:
	el=RelationalExpression (INSTANCEOF target=(RelationalExpression|ClassOrInterfaceType))?
;

AdditiveExpression returns Expression:
	multExpr+=MultiplicativeExpression (('+' | '-') multExpr+=MultiplicativeExpression)*	
;

MultiplicativeExpression returns Expression:
	baseExpr+=BaseCommonExpression (DOT methods+=MethodInvocation)* (('*' | '/') baseExpr+=BaseCommonExpression (DOT methods+=MethodInvocation)*)*
;

RelationalOp:
	GT | GTE | LT | LTE
;

//conditionalExpression:
//	conditionalOrExpression=conditionalOrExpression
//	('?' expression=Expression ':' conditionalExpression=conditionalExpression)?;
//
//conditionalOrExpression:
//	conditionalAndExpression+=conditionalAndExpression
//	('||' conditionalAndExpression+=conditionalAndExpression)*;
//
//conditionalAndExpression:
//	inclusiveOrExpression+=inclusiveOrExpression
//	('&&' inclusiveOrExpression+=inclusiveOrExpression)*;
//
//inclusiveOrExpression:
//	exclusiveOrExpression+=exclusiveOrExpression
//	('|' exclusiveOrExpression+=exclusiveOrExpression)*;
//
//exclusiveOrExpression:
//	andExpression+=andExpression
//	('^' andExpression+=andExpression)*;
//
//andExpression:
//	equalityExpression+=equalityExpression
//	('&' equalityExpression+=equalityExpression)*;
//
//equalityExpression:
//	instanceOfExpression+=InstanceOfExpression
//	(('=='
//	| '!=')
//	instanceOfExpression+=InstanceOfExpression)*;
//
//InstanceOfExpression:
//	relationalExpression=relationalExpression
//	('instanceof' type=Type)?;
//
//relationalExpression:
//	shiftExpression+=shiftExpression
//	(relationalOp shiftExpression+=shiftExpression)*;
//
//terminal relationalOp:
//	'<' '='
//	| '>' '='
//	| '<'
//	| '>';
//
//shiftExpression 
//    :   additiveExpression+=additiveExpression
//        (shiftOp additiveExpression+=additiveExpression
//        )*
//    ;
//
//terminal shiftOp:
//	'<' '<'
//	| '>' '>' '>'
//	| '>' '>';
//
//
//additiveExpression:
//	multiplicativeExpression+=multiplicativeExpression
//	(('+'
//	| '-')
//	multiplicativeExpression+=multiplicativeExpression)*;
//
//multiplicativeExpression:
//	unaryExpression+=unaryExpression
//	(('*'
//	| '/'
//	| '%')
//	unaryExpression+=unaryExpression)*;
//
///**
// * NOTE: for '+' and '-', if the next token is int or long interal, then it's not a unary expression.
// *       it's a literal with signed value. INTLTERAL AND LONG LITERAL are added here for this.
// */
//unaryExpression:
//	'+' unaryExpression=unaryExpression
//	| '-' unaryExpression=unaryExpression
//	| '++' unaryExpression=unaryExpression
//	| '--' unaryExpression=unaryExpression
//	| unaryExpressionNotPlusMinus;
//
//unaryExpressionNotPlusMinus:
//	'~' unaryExpression=unaryExpression
//	| '!' unaryExpression=unaryExpression
//	| castExpression=CastExpression
//	| primary
//	(selector+=selector)*
//	('++'
//	| '--')?;
//	
//primary:
//	parExpression=parExpression
//	| this='this'
//	(dot+=DOT identifier+=IDENTIFIER)*
//	(identifierSuffix=identifierSuffix)?
//	| identifier+=IDENTIFIER
//	(dot+=DOT identifier+=IDENTIFIER)*
//	(identifierSuffix=identifierSuffix)?
//	| 'super'
//	superSuffix=superSuffix
//	| literal=Literal
//	| creator=Creator
//	| primitiveType=PrimitiveType
//	(lbrack+=LBRACKET rbrack+=RBRACKET)*
//	dot+=DOT 'class'
//	| 'void' dot+=DOT 'class';
//
//parExpression 
//    :   LPAREN Expression RPAREN
//    ;
//
//superSuffix:
//	Arguments
//	| dot=DOT
//	identifier=IDENTIFIER
//	(arguments=Arguments)?;
//
//
//identifierSuffix:
//	(LBRACKET RBRACKET)+
//	dot+=DOT 'class'
//	| (LBRACKET expression+=Expression RBRACKET)+
//	| arguments=Arguments
//	| dot+=DOT 'class'
//	| dot+=DOT IDENTIFIER arguments=Arguments
//	| dot+=DOT 'this'
//	| dot+=DOT 'super' arguments=Arguments
//	| innerCreator=InnerCreator;
//
//selector:
//	dot=DOT identifier=IDENTIFIER
//	(arguments=Arguments)?
//	| dot=DOT 'this'
//	| dot=DOT 'super'
//	superSuffix=superSuffix
//	| innerCreator=InnerCreator
//	| LBRACKET expression=Expression RBRACKET;	


Creator:
	ClassCreator | ArrayCreator;

ClassCreator:
	NEW clazz=ClassOrInterfaceType args=Arguments
;

ArrayCreator:
	NEW type=ArrayType arrayInitializer=ArrayInitializer;

ArrayInitializer:
	{ArrayInitializer}
	LBRACE
	(firstEl=Expression
	(COMMA otherEls+=Expression)*)?
	(COMMA)?
	RBRACE;

InnerCreator:
	DOT NEW
	IDENTIFIER
	args=Arguments;
	
ArrayType:
	(clazzInterf=ClassOrInterfaceType
	| primtype=PrimitiveType)
	(LBRACKET RBRACKET)+;

ClassOrInterfaceType:
	qualifiedName=QualifiedName
;
	
QualifiedName:
	{QualifiedName} identifier+=IDENTIFIER
	(dot+=DOT identifier+=IDENTIFIER)*;

Literal:
	INTLITERAL
	| LONGLITERAL
	| FLOATLITERAL
	| DOUBLELITERAL
	| CHARLITERAL
	| STRINGLITERAL
	| TRUE
	| FALSE
	| NULL;
	
PrimitiveType:
	('boolean'
	| 'char'
	| 'byte'
	| 'short'
	| 'int'
	| 'long'
	| 'float'
	| 'double');
	
terminal FieldToken:
	'$F' BRACED_JRIDENTIFIER
;

terminal VariableToken:
	'$V' BRACED_JRIDENTIFIER
;

terminal ParameterToken:
	'$P' BRACED_JRIDENTIFIER
;
	
// ============= TERMINAL RULES ============= //
terminal fragment BRACED_JRIDENTIFIER:
	LBRACE JRIDENTIFIER RBRACE	
;

terminal LONGLITERAL:
	IntegerNumber LongSuffix;

terminal INTLITERAL:
	IntegerNumber;
    
terminal fragment IntegerNumber:
	'0'
	| '1'..'9' ('0'..'9')*
	| '0' ('0'..'7')+
	| HexPrefix HexDigit+;

terminal fragment HexPrefix:
	'0x' | '0X';
        
terminal fragment HexDigit:
	('0'..'9' | 'a'..'f' | 'A'..'F');

terminal fragment LongSuffix:
	'l' | 'L';

terminal fragment NonIntegerNumber:
	('0'..'9')+ '.' ('0'..'9')* Exponent?
	| '.' ('0'..'9')+ Exponent?
	| ('0'..'9')+ Exponent
	| ('0'..'9')+
	|
	HexPrefix (HexDigit)*
	('.' (HexDigit)*)
	('p' | 'P')
	('+' | '-')?
	('0'..'9')+;
        
terminal fragment Exponent:
	('e' | 'E') ('+' | '-')? ('0'..'9')+;
    
terminal fragment FloatSuffix:
	'f' | 'F';     

terminal fragment DoubleSuffix:
	'd' | 'D';
        
terminal FLOATLITERAL:
	NonIntegerNumber FloatSuffix;
    
terminal DOUBLELITERAL:
	NonIntegerNumber DoubleSuffix?;

terminal CHARLITERAL:
	'\''
	(EscapeSequence
	| !('\'' | '\\' | '\r' | '\n'))
	'\''; 

terminal STRINGLITERAL:
	'"'
	(EscapeSequence
	| !('\\' | '"' | '\r' | '\n'))*
	'"';
	
terminal fragment EscapeSequence:
	'\\' ('b'
	| 't'
	| 'n'
	| 'f'
	| 'r'
	| '\"'
	| '\''
	| '\\'
	|
	('0'..'3') ('0'..'7') ('0'..'7')
	|
	('0'..'7') ('0'..'7')
	|
	('0'..'7'));
	
terminal TRUE:
	'true';

terminal FALSE:
	'false';

terminal NULL:
	'null';

terminal LPAREN:
	'(';

terminal RPAREN:
	')';

terminal LBRACE:
	'{';

terminal RBRACE:
	'}';

terminal LBRACKET:
	'[';

terminal RBRACKET:
	']';

terminal SEMI:
	';';

terminal COMMA returns ecore::EString:
	',';

terminal DOT:
	'.'; 
	
terminal NOTEQUAL:
	'!='
;

terminal EQUAL:
	'=='
;

terminal GT:
	'>'
;

terminal GTE:
	'>='
;

terminal LT:
	'<'
;

terminal LTE:
	'<='
;

terminal NEW:
	'new'
;

terminal INSTANCEOF:
	'instanceof'
;

terminal NOT:
	'!'
;

terminal IDENTIFIER:
	LETTER (LETTER | JavaIDDigit)*;
	
terminal fragment LETTER:
	'\u0024' |
	'\u0041'..'\u005a' |
	'\u005f' |
	'\u0061'..'\u007a' |
	'\u00c0'..'\u00d6' |
	'\u00d8'..'\u00f6' |
	'\u00f8'..'\u00ff' |
	'\u0100'..'\u1fff' |
	'\u3040'..'\u318f' |
	'\u3300'..'\u337f' |
	'\u3400'..'\u3d2d' |
	'\u4e00'..'\u9fff' |
	'\uf900'..'\ufaff';
	
terminal fragment JavaIDDigit:
	'\u0030'..'\u0039' |
	'\u0660'..'\u0669' |
	'\u06f0'..'\u06f9' |
	'\u0966'..'\u096f' |
	'\u09e6'..'\u09ef' |
	'\u0a66'..'\u0a6f' |
	'\u0ae6'..'\u0aef' |
	'\u0b66'..'\u0b6f' |
	'\u0be7'..'\u0bef' |
	'\u0c66'..'\u0c6f' |
	'\u0ce6'..'\u0cef' |
	'\u0d66'..'\u0d6f' |
	'\u0e50'..'\u0e59' |
	'\u0ed0'..'\u0ed9' |
	'\u1040'..'\u1049';
	
terminal fragment JRIDENTIFIER:
	(!('\r' | '\n' | '}' ))+
;    

terminal ML_COMMENT	: '/*' -> '*/';
terminal SL_COMMENT 	: '//' !('\n'|'\r')* ('\r'? '\n')?;

terminal WS			: (' '|'\t'|'\r'|'\n')+;